import json
import sys
import itertools


def next_grid(volume):
    # Generates all possible matrices representing a volume <volume>
    # defining distinct lattices in 3d space. See: https://oeis.org/A001001:
    # These sublattices are in 1-1 correspondence with matrices
    # [a b d]
    # [0 c e]
    # [0 0 f]
    # with acf = n, b = 0..c-1, d = 0..f-1, e = 0..f-1.

    # next_diagonal() enumerates all possible diagonals by recursive
    # factorization of volume, and the loop at the end adds all
    # possible b, d and e elements.

    diagonal = [0, 0, 0]
    def next_diagonal(n):
        if n == 2:
            diagonal[n] = volume // diagonal[0] // diagonal[1]
            # we need to make a copy here!
            yield list(diagonal)
            return
        if n == 0:
            v = volume
        else:
            v = volume // diagonal[0]
        i = 1
        while i * i <= v:
            if v % i != 0:
                i += 1
                continue
            diagonal[n] = i
            yield from next_diagonal(n+1)
            if i * i != v:
                diagonal[n] = v // i
                yield from next_diagonal(n+1)
            i += 1

    diagonals = list(next_diagonal(0))
    diagonals = sorted(diagonals, key=max)
    for diag in diagonals:
        for b in range(diag[1]):
            for d in range(diag[2]):
                for e in range(diag[2]):
                    # it looks like the mirrored mattrix is needed here to get
                    # the correct transforms
                    yield ((diag[2], 0, 0), (e, diag[1], 0), (b, d, diag[0]))
                    # yield ((diag[0], 0, 0), (b, diag[1], 0), (d, e, diag[2]))


def rotate_x(block):
    return tuple([(x, -z, y) for x, y, z in block])


def rotate_y(block):
    return tuple([(z, y, -x) for x, y, z in block])


def rotate_z(block):
    return tuple([(-y, x, z) for x, y, z in block])


def norm(block):
    minx = block[0][0]
    miny = block[0][1]
    minz = block[0][2]
    for x, y, z in block:
        minx = min(minx, x)
        miny = min(miny, y)
        minz = min(minz, z)
    return tuple([(x-minx, y-miny, z-minz) for x, y, z in block])


def get_cover(block, x, y, z, idx, offsets):
    # block[idx] shall be positioned at (x, y, z)
    cells_covered = set()
    D0 = offsets[0][0]
    D1 = offsets[1][1]
    D2 = offsets[2][2]
    dx = x - block[idx][0]
    dy = y - block[idx][1]
    dz = z - block[idx][2]
    for xb, yb, zb in block:
        x1 = xb + dx
        y1 = yb + dy
        z1 = zb + dz
        # Transform (x1, y1, z1) into a cell in [0..D0-1][0..D1-1][0..D2-1]
        # Luckily with python, this modulo arithmetic works as expected
        # also for negative numbers!
        y1 -= (z1 // D2) * offsets[2][1]
        x1 -= (z1 // D2) * offsets[2][0]
        z1 %= D2

        x1 -= (y1 // D1) * offsets[1][0]
        y1 %= D1

        x1 %= D0

        # s will be now in the range(0..volume)
        s = x1 * D1 * D2 + y1 * D2 + z1
        cells_covered.add(s)
    return tuple(cells_covered)


def place(block, x, y, z, idx, offsets):
    dx = x - block[idx][0]
    dy = y - block[idx][1]
    dz = z - block[idx][2]
    translated = []
    for xb, yb, zb in block:
        x1 = xb + dx
        y1 = yb + dy
        z1 = zb + dz
        translated.append((x1, y1, z1))
    return tuple(translated)


def tile_for_offsets(block, offsets):
    # offsets is expected here to by a triangular matrix
    # as generated by next_grid()

    D0 = offsets[0][0]
    D1 = offsets[1][1]
    D2 = offsets[2][2]
    volume = D0 * D1 * D2
    # Placing a block at some position will cover some cells in the basic
    # parallelepiped [0..D0-1][0..D1-1][0..D2-1].
    # We enumerate each x, y, z of these as x * D1 * D2 + y * D2 + z.
    # possibilities[i] will be a dictionary with keys being all
    # possible such tuples that include i (values in the dictionaries are data to
    # help reconstruct the solution at the end).
    # Then, if we try to fill cell i, we can check one by one the keys
    # in possibilities[i].
    #
    # Example:
    # If a block in some orientation and translation covers cells: (2, 5, 13, 24)
    # (cells are defined by an integer between 0..volume-1 as described above),
    # Then possibilities[2], possibilities[5], possibilities[13] and possibilities[24]
    # will all contain the key (2, 5, 13, 24) each.
    # possibilities[2][(2, 5, 13, 24)] will be some data structure helping later
    # for generating the actual result data.
    #
    # UPDATE:
    # Because of the way the dfs is run, we don't need to store the set at all
    # positions, but only in the smallest position. In the above example, when
    # we are trying to fill cell 5, there is no need to check set (2, 5, 13, 24),
    # because we know cell 2 is already covered!

    possibilities = [{} for i in range(volume)]

    # create all rotations
    def next_rotation():
        b = block
        for i in range(3):
            for j in range(4):
                b = norm(rotate_y(b))
                yield b
            b = norm(rotate_x(b))
            for j in range(4):
                b = norm(rotate_y(b))
                yield b
            b = norm(rotate_z(b))


    for b in next_rotation():
        for x, y, z in itertools.product(range(D0), range(D1), range(D2)):
            for i in range(len(block)):
                bitmap = get_cover(b, x, y, z, i, offsets)
                if len(bitmap) != len(block):
                    continue
                s = min(bitmap)
                possibilities[s][bitmap] = (b, x, y, z, i)

    covered = set()
    solution = [None] * volume

    def dfs(idx):
        if idx == volume:
            return True
        if idx in covered:
            return dfs(idx + 1)
        for bitmap, data in possibilities[idx].items():
            collision = False
            for cell in bitmap:
                if cell in covered:
                    collision = True
                    break
            if collision:
                continue
            for cell in bitmap:
                covered.add(cell)
            solution[idx] = data
            if dfs(idx + 1):
                return True
            for cell in bitmap:
                covered.remove(cell)
            solution[idx] = None

            if idx == 0:
                # Since we try all possible permutations of the offsets matrix,
                # we can start the dfs by positioning a random block in
                # a random position to avoid checking symmetrically equivalent
                # cases many times.
                # This is easy done here by breaking the iteration after the first
                # loop in the first step of recursion (idx == 0)
                break
        return False

    if len(possibilities[0]) == 0:
        # Nothing fits in the first cell...
        return None

    if dfs(0):
        result = {
                "original_block": block,
                "base_blocks": [],
                "offsets": offsets
        }
        for s in solution:
            if s is None:
                continue
            b, x, y, z, i = s
            result["base_blocks"].append(place(b, x, y, z, i, offsets))
        return result
    return None


def tile_space(block):
    """
    :param block: tuple of coordinates-tuples defining the block to use for tiling
                  e.g. ((0,0,0), (1,0,0), (1,1,0), (2,1,0), (2,2,0)) would be the
                  W-Pentomino laying flat on the z=0 plane.
                  The block can be anywhere in space, does not need to be at
                  the origin.
    :return: a dictionary with keys "base_blocks": a list of non overlapping blocks
                  in the same format as the input, and "offsets": a list of 3 vectors
                  indicating the directions to repeat the base_blocks to tile the
                  whole space. That means, there is a block at every position:
                  base_blocks[i] + a * offsets[0] + b * offsets[1] + c * offsets[2]
                  (vector operations).
    """
    N = len(block)
    tiling = None
    num_blocks_in_pattern = 0
    while tiling is None:
        num_blocks_in_pattern += 1
        # print("N:", num_blocks_in_pattern)
        for offsets in next_grid(num_blocks_in_pattern * N):
            tiling = tile_for_offsets(block, offsets)
            if tiling is not None:
                break

    return tiling


if __name__ == "__main__":
    data = json.loads(sys.stdin.read().strip())
    tiling = tile_space(data)
    print(json.dumps(tiling))
