import json
import sys


def next_grid(volume):
    for y in range(volume):
        for z in range(y, volume):
            yield ((volume, 0, 0), (y, 1, 0), (z, 0, 1))


def rotate_x(block):
    return tuple([(x, -z, y) for x, y, z in block])


def rotate_y(block):
    return tuple([(z, y, -x) for x, y, z in block])


def rotate_z(block):
    return tuple([(-y, x, z) for x, y, z in block])


def norm(block):
    minx = block[0][0]
    miny = block[0][1]
    minz = block[0][2]
    for x, y, z in block:
        minx = min(minx, x)
        miny = min(miny, y)
        minz = min(minz, z)
    return tuple([(x-minx, y-miny, z-minz) for x, y, z in block])


def get_cover(block, x0, idx, offsets):
    # block[idx] shall be positioned at (x0, 0, 0)
    cells_covered = set()
    dx = x0 - block[idx][0]
    dy = -block[idx][1]
    dz = -block[idx][2]
    for x, y, z in block:
        x1 = x + dx
        y1 = y + dy
        z1 = z + dz
        x1 -= offsets[2][0] * z1 + offsets[1][0] * y1
        x1 %= offsets[0][0]
        cells_covered.add(x1)
    return tuple(cells_covered)


def place(block, x0, idx, offsets):
    dx = x0 - block[idx][0]
    dy = -block[idx][1]
    dz = -block[idx][2]
    translated = []
    for x, y, z in block:
        x1 = x + dx
        y1 = y + dy
        z1 = z + dz
        translated.append((x1, y1, z1))
    return tuple(translated)


def tile_for_offsets(block, offsets):
    # offsets is expected here to by a triangular matrix with diagonal (volume, 1, 1)
    # as generated by next_grid()

    volume = offsets[0][0]
    # Placing a block at some position will cover some of the first volume cells
    # in the x axis. possibilities[i] will be a dictionary with keys being all
    # possible such tuples that include i (values in the dictionaries are data to
    # help reconstruct the solution at the end).
    # Then, if we try to fill cell i, we can check one by one the keys
    # in possibilities[i].
    possibilities = [{} for i in range(volume)]

    # create all rotations
    def next_rotation():
        b = block
        for i in range(3):
            for j in range(4):
                b = norm(rotate_y(b))
                yield b
            b = norm(rotate_x(b))
            for j in range(4):
                b = norm(rotate_y(b))
                yield b
            b = norm(rotate_z(b))


    for b in next_rotation():
        for x0 in range(volume):
            for i in range(len(block)):
                bitmap = get_cover(b, x0, i, offsets)
                if len(bitmap) != len(block):
                    continue
                for s in bitmap:
                    possibilities[s][bitmap] = (b, x0, i)

    covered = set()
    solution = [None] * volume

    def dfs(idx):
        if idx == volume:
            return True
        if idx in covered:
            return dfs(idx + 1)
        for bitmap, data in possibilities[idx].items():
            collision = False
            for cell in bitmap:
                if cell in covered:
                    collision = True
                    break
            if collision:
                continue
            for cell in bitmap:
                covered.add(cell)
            solution[idx] = data
            if dfs(idx + 1):
                return True
            for cell in bitmap:
                covered.remove(cell)
            solution[idx] = None
        return False

    if dfs(0):
        result = {
                "original_block": block,
                "base_blocks": [],
                "offsets": offsets
        }
        for s in solution:
            if s is None:
                continue
            b, x0, i = s
            result["base_blocks"].append(place(b, x0, i, offsets))
        return result
    return None


def tile_space(block):
    """
    :param block: tuple of coordinates-tuples defining the block to use for tiling
                  e.g. ((0,0,0), (1,0,0), (1,1,0), (2,1,0), (2,2,0)) would be the
                  W-Pentomino laying flat on the z=0 plane.
                  The block can be anywhere in space, does not need to be at
                  the origin.
    :return: a dictionary with keys "base_blocks": a list of non overlapping blocks
                  in the same format as the input, and "offsets": a list of 3 vectors
                  indicating the directions to repeat the base_blocks to tile the
                  whole space. That means, there is a block at every position:
                  base_blocks[i] + a * offsets[0] + b * offsets[1] + c * offsets[2]
                  (vector operations).
    """
    N = len(block)
    tiling = None
    num_blocks_in_pattern = 0
    while tiling is None:
        num_blocks_in_pattern += 1
        for offsets in next_grid(num_blocks_in_pattern * N):
            tiling = tile_for_offsets(block, offsets)
            if tiling is not None:
                break

    return tiling


if __name__ == "__main__":
    data = json.loads(sys.stdin.read().strip())
    tiling = tile_space(data)
    print(json.dumps(tiling))
