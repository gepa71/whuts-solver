# whuts-solver
Code to find solutions for tiling the space by any of the 3d unfoldings of a 4d hypercube. See Matt Parker's video for details: https://www.youtube.com/watch?v=Yq3P-LhlcQo

### Algorithm Description

The code tries to find symmetric tilings, that can be generated by a basic pattern, repeated infinitely in 3 directions in space.

If we start with 3 vectors in general position, it will be only possible to find a tiling if the vectors span a parallelepiped with volume a multiple of 8 (since the unfoldings we start with have a volume 8). This is a necessary (but of course not sufficient) condition. Basically that means the determinant of the matrix containing the 3 offset vectors has to be a multiple of 8. We start be generating some matrices with determinant 8, then continue with some with determinant 16, and so on until we find a solution.

Every time we have defined an offset matrix, we do a backtracking algorithm by placing some rotation/translation of the unfolding and checking if it fits, backtracking if not. There is some preprocessing for precomputing which cells are covered by each rotation/translation to optimize the backtracking search.

There is the problem of how to find all matrices with a given determinant that generate distinct grids of points (e.g. in 2d the matrices ((1,1), (1,-1)) and ((1,1),(3,7)) will generate the same grid of points if repeated infinitely in all directions. I couldn't find a simple answer to this (I am sure there is one out there), so initially (not in this code) I tried some random matrices and keeping the ones with determinant `n*8` and checking if some generate the same grid to keep one of them. For this code I thought (not sure how I came up with that thought) that I could generate all possible distinct ways by using vectors (v, 0, 0), (a, 1, 0), (b, 0, 1) for a and b between 0 and v-1. I now realized that this is wrong (my older code found a solution for octocube_1325 with basic pattern volume 32, in contrast the smallest one that this code could find had volume 48).

### Bugs

See in the description above, not all possible matrices for a given volume are tried out, missing out some smaller solutions. It was still fast enough in python to find solutions to all but 3 possible octocubes.


### Fix

I found the solution to the way to generate all useful matrices here: https://oeis.org/A001001

> These sublattices are in 1-1 correspondence with matrices

> `[a b d]`

> `[0 c e]`

> `[0 0 f]`

> with `acf = n, b = 0..c-1, d = 0..f-1, e = 0..f-1`. The sublattice is primitive if `gcd(a,b,c,d,e,f) = 1`.

So basically I came quite close with my assumption, missed to include `e` for some reason, and also I was thinking that I can reduce the `acf` product to be `volume * 1 * 1`. I will fix the code later accordingly.


### Usage Example
`echo '[[0,0,0],[0,0,-1],[0,-1,-1],[0,-1,-2],[-1,-1,-2],[1,0,0],[1,0,1],[1,1,1]]' | python3 whuts.py`

The input is in the format of the field `coords` in https://api.whuts.org/unfoldings

To get the tiling for unfolding `<N>` having that file can be done by:

`cat unfoldings | jq '.unfoldings[] | select(.id==<N>) .coords' | python3 whuts.py`

### Results

I run the code for all possible octocubes (octominoes in 3d?). The octocubes are generated by the file `generate_octocubes.py`. The program could find solutions for all but 3 octocubes! From those 3 I could find a tiling for 2 of those using a similar code in C that runs faster. The solutions are in the directory `octocube_solutions`. These cover of course also all hypercube unfoldings, which is a subset of all octocubes. I run the code separate again for the unfoldings and saved the tilings in `unfolding_solutions`. The numbering there is the same as in https://whuts.org

This is the octocube for which the code could not find a tiling (yet?):

```
    ###
    #.#
    ###
```

Due to the very restrictive nature of this one (two of these have to be pairwise connected, so it reduces to finding a tiling of space using the 16-cube containing two of these instances connected together), I tried writing more optimized C code, but still didn't get any results. I will update here if something is found.
